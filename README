README file for JADE, Version 0.71

INTRODUCTION
============

This package contains a Java framework to build agent-based systems
according to FIPA standard specifications.



LICENSE
=======




SYSTEM REQUIREMENTS
===================

To build the framework a complete Java programming environment is
needed. At least a Java Development Kit version 1.1 is required, due
to Remote Method Invocation (RMI) API usage. Besides, JavaCC 0.8pre is
needed to generate Java code from grammar description files.


INSTALLATION AND TEST
==============================

After uncompressing the archive, you will have a directory tree
starting with JADE; from that directory, you can type

- make clean 		To remove compiled classes, HTML docs and the like.

- make src		To compile source code and create RMI stubs and skeletons.

- make lib		To create a compressed file in 'lib' directory, containing all compiled classes.

- make doc		To create HTML documentation for the framework in 'doc' directory.

- make examples		To build example programs.

- make all		Performs 'make lib', 'make doc' and 'make examples'


After compiling, one can run the example programs in 'src/examples'
subdirectory; remember to set CLASSPATH environment variable to
include the zip file in 'lib' directory and the current directory,
then change to 'src' directory.

The Agent Platform uses Java RMI, so one has to start the RMI registry
on the same host the Agent Platform will run on. Be careful to set a
suitable CLASSPATH (i.e. including both the zip file with compiled
classes and the current directory) *also* in the command shell where
you start the RMI registry, otherwise you will get a
'ClassNotFoundException' during 'Naming.bind()' operation.

To run the Agent Platform, one must issue the command:

	java jade.Boot -platform [options] [Agent list]

Use -h option to get a list of command line arguments.

To start some agents on additional hosts, one must create and run more
Agent Containers; these components connect themselves with the main
Agent Platform, resulting in a distributed system that seems a single
Agent Platform from outside.

An Agent Container can be started using the command:

	java jade.Boot [options] [Agent list]

Again, using -h command-line option explains program usage. As can be
seen from above, the same command is issued in the two cases, with the
'-platform' command-line switch used to choose between an ordinary
Agent Container and the global Agent Platform.

Using command-line options, users can state host name and port number
where the main Agent Platform resides, and the name with which it is
registered in RMI Registry. This way, multiple platform can be
executed on a single host.

The agent list is a sequence of character strings; each one of them
must be broken in two parts by a colon ':'. The substring before the
colon is taken as the agent name, whereas the substring after the
colon is the name of the Java class implementing the agent. This class
will be dynamically loaded by the Agent Container.

For example, a string 'Peter:myAgent' means "create a new agent named
Peter whose implementation is an object of class myAgent". The name of
the class must be fully qualified, (e.g. Peter:myPackage.myAgent) and
will be searched for according to CLASSPATH definition.

After compilation, some simple agents (just to test the basic platform
mechanisms) can be found in test subdirectory. The following list
gives some explanations:

 - Agent1.class			An agent with a cyclic behaviour, printing 
				a message once in a second. This shows
				how an agent behaviour can be defined
				in a class implementing
				jade.core.Behaviour interface.

 - Agent2.class			An agent which executes three times and then
				stops. This example shows how a
				behaviour can be defined extending
				jade.core.SimpleBehaviour class. It
				also shows how an agent without active
				behaviours is blocked.

 - Agent3.class			An agent with a behaviour made of many steps,
				with some steps that have sub-steps
				themselves. This examples shows how
				jade.core.ComplexBehaviour class
				allows the construction of aggregate
				behaviours starting from simpler ones,
				even with recursive aggregations.
				Besides, it shows the cooperative
				multitasking presently used for
				intra-agent behaviour scheduling.

 - AgentReceiver.class		This example creates an agent that continously
				waits for messages and sends back automated 
				replies; it shows how to create a simple
				server agent, purely reactive.

 - AgentSender.class		This agent works together with AgentReceiver
				to build a simple client/server
				interaction. The agent asks the user
				for a message and an agent name. It
				then sends the string to the specified agent.
				This example, together with the
				previous one, shows how the
				distributed Agent Platform allows
				message passing between the agents.

 - AgentBroadcaster.class	This agent combines message passing with
				ComplexBehaviour class to achieve
				more complex interactions between agents.
				This Agent asks for a string and three
				agent names; then it sends the string
				to each one of the three agents,
				collecting the replies. Eventually, it
				prints the concatenation of the three
				replies.


BUGS
====



TODO
====

 - Add system-level agents to fully support FIPA 97 specification:
   Agent Communication Channel, Agent Management System and Directory
   Facilitator.

 - Add support for standard and user defined interaction protocols.

 - Add support for message content language parsing.

 - Add support for message ontology checking.

 - Add support for platform administration and direct agent
   manipulation through a GUI.

CONTACT
=======




