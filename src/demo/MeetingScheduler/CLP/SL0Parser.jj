options {
  LOOKAHEAD = 1;	      
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = true;	// Force LookAhead Cecking
}

PARSER_BEGIN(SL0Parser)

/* $Id: SL0Parser.jj,v 1.2 1999/01/29 06:22:05 bellifemine Exp bellifemine $

   $Log: SL0Parser.jj,v $
   Revision 1.2  1999/01/29 06:22:05  bellifemine
   <>

   Revision 1.1  1999/01/29 03:33:28  bellifemine
   Initial revision

   Revision 1.1  1999/01/18 15:44:47  bellifemine
   Initial revision

   Revision 1.2  1998/12/16 12:52:50  bellifemine
   Removed bug in OntologyObject.toString()

   Revision 1.1  1998/12/14 11:58:58  bellifemine
   Initial revision

*/

package demo.MeetingScheduler.CLP;
import java.io.*;

/**
 * This class implements the content language parser of the SL0 Language.
 * It takes in input a String with the content to parse and gives in output
 * a tree. Each node of the tree is an OntologyObject class.
 * <p> The parser must be used as follows:
 * <code> 
 * <p> ACLMessage msg = myAgent.receive();
 * <p> SL0Parser parser = SL0Parser.create();
 * <p> try { 
 * <p>     OntologyObject obj = parser.parse(new StringReader(msg.getContent()), msg.getType());
 * <p>     switch (obj.getType()) :
 * <p>      case ACTION_TYPE: { Action a=(Action)obj; 
 * <p>                          apply to a the interface of Action.java }
 * <p>      case OBJECT_TYPE: { Concept c=(Concept)obj; 
 * <p>                          apply to c the interface of Concept.java }
 * <p>      case PROPOSITION_TYPE: { Proposition p=(Proposition)obj; 
 * <p>                          apply to p the interface of Proposition.java }
 * <p>      case OBJECTDESCRIPTOR_TYPE: { ObjectDescriptor od=(ObjectDescriptor)obj; 
 * <p>                          apply to od the interface of ObjectDescriptor.java }
 * <p>      case SIMPLEVALUE_TYPE: { SimpleValue s=(SimpleValue)obj; 
 * <p>                          apply to s the interface of SimpleValue.java }
 * <p>      case MULTIVALUE_TYPE: { MultiValue m=(MultiValue)obj; 
 * <p>                          apply to m the interface of MultiValue.java }
 * <p>     }
 * <p> catch (CLP.ParseException pe) {
 * <p>     pe.printStackTrace();
 * <p>     System.exit(1); // parsing error
 * <p> }
 * </code>
 * <p> Notice that the direct interface provided by OntologyObject should
 * never be used and the object returned by the parser should always be
 * first casted to its actual type and then used.
 * <p> The classes derived by OntologyObject can also be used to create
 * the content message, by calling their set methods and then by calling
 * <code> msg.setContent(object.toString()); </code>
 * <p>
 * <img src="OntologyObject.jpg">
 * @see OntologyObject
*/
public class SL0Parser {

  /**
   * This method allows the parser to be also a stand-alone Java application
   * You can run the parser simply typing 
   * <code>java myagents.SL0Parser < myagents\content.txt
   *
   * @param args is the list of arguments to the application 
   * @exception ParseException is generated when there is a parsing error
   */
  public static void main(String args[]) throws ParseException { 
    String    aclType = "cfp";
    SL0Parser parser = new SL0Parser(System.in);
    int i=0;
    
    while (true) {
      System.out.println("This main has been compiled only to parse " + aclType);
      try {
        System.out.println("MESSAGE No. "+i);
	OntologyObject c = parser.ContentExpression(aclType);
	System.out.println(c.toString()); 
        i++;
      }
      catch(ParseException pe) {
	pe.printStackTrace();
	System.exit(1);
      }
    }
  }

  public static SL0Parser create() {
    Reader r = new StringReader("");
    return new SL0Parser(r);
  }

 /**
  * This method parses a Reader and returns an OntologyObject
  * @param text contains the text to be parsed
  * @param ACLMessageType contains the string with the type of ACLMessage to
  * which this message refers (e.g. "inform", "request", ...)
   * @exception ParseException is generated when there is a parsing error
  */
  public OntologyObject parse(Reader text, String ACLMessageType) throws ParseException {
    ReInit(text);
    return ContentExpression(ACLMessageType);
  }


  /**
   * given a string with an ACLMessageType returns an integer according to
   * the expected content:
   * 0 if a Proposition is expected
   * 1 if an Action is expected
   * 2 if an ObjectDescriptor is expected
   * 3 if a t-uple Action + Proposition is expected
   * -1 otherwise
  */
  private int ACLMessageTypeToInt(String t) {
   if (t.equalsIgnoreCase("accept-proposal")) return 3;
   if (t.equalsIgnoreCase("agree")) return 3;
   if (t.equalsIgnoreCase("cancel")) return 1;
   if (t.equalsIgnoreCase("cfp")) return 3;
   if (t.equalsIgnoreCase("confirm")) return 0;
   if (t.equalsIgnoreCase("disconfirm")) return 0;
   if (t.equalsIgnoreCase("failure")) return 3;
   if (t.equalsIgnoreCase("inform")) return 0;
   if (t.equalsIgnoreCase("not-understood")) return 3;
   if (t.equalsIgnoreCase("propose")) return 3;
   if (t.equalsIgnoreCase("query-if")) return 0;
   if (t.equalsIgnoreCase("query-ref")) return 2;
   if (t.equalsIgnoreCase("refuse")) return 3;
   if (t.equalsIgnoreCase("reject-proposal")) return 3;
   if (t.equalsIgnoreCase("request")) return 1;
   if (t.equalsIgnoreCase("request-when")) return 3;
   if (t.equalsIgnoreCase("request-whenever")) return 3;
   if (t.equalsIgnoreCase("subscribe")) return 2;
   return -1;
  }

  /**
   * This method parse a content expression and returns a tree of java objects,
   * starting from the returned OntologyObject
   * that represents the expression
   * @param ACLMessageType is the string with the type of ACLMessage that
   * embeddes this content (e.g. "request", "inform", ...)
   * @exception ParseException is generated when there is a parsing error
   * @return the root of the tree of java objects
  */
  public OntologyObject ContentExpression(String ACLMessageType) throws ParseException {
   int i = ACLMessageTypeToInt(ACLMessageType);
   switch (i) {
   case 0: return Proposition(); 
   case 1: return Action(); 
   case 2: return ObjectDescriptor(); 
   case 3: return ActionAndProposition(); 
   default: return Proposition();
   }
  }





}
PARSER_END(SL0Parser)





/*   P R O D U C T I O N    R U L E S  */

OntologyObject ActionAndProposition():
{ MultiValue obj = new MultiValue();
  OntologyObject obj1,obj2; }
{
 <LBRACE> obj1=Action() obj2=Proposition() <RBRACE>
 { obj.addValue(obj1); obj.addValue(obj2); return obj; }
}

OntologyObject Proposition():
{ OntologyObject obj;
  Proposition objj = new Proposition();
  Token t;
}
{
 <LBRACE> obj=PropositionWithoutBraces() <RBRACE> {return(obj);}
| t=<WORD> {objj.setName(t.image); return(objj);} // propositionsymbol 
}


OntologyObject PropositionWithoutBraces() :
{ Token t,t2; 
  Proposition obj = new Proposition();
  OntologyObject obj1;}
{
  <DONE> obj1=Action() {obj.setName("done"); 
                        obj.addTerm(obj1);
		        return obj;}
| t=<WORD> 
 (obj1=SL0Term() {obj.addTerm(obj1);})* 
  {obj.setName(t.image); return obj;}
}






OntologyObject ObjectDescriptor() :
{ Token t;
  ObjectDescriptor obj=new ObjectDescriptor();
  OntologyObject obj2; }
{ 
<LBRACE> <IOTA> t=<WORD> 
  <LBRACE> obj2=PropositionWithoutBraces() <RBRACE> <RBRACE> 
    {obj.setIotaPattern(0);
     obj.setObjectName(t.image);
     obj.addDescription((Proposition)obj2);
     return obj;}
}


OntologyObject Action() :
{ OntologyObject obj; }
{
  <LBRACE> obj=ActionWithoutBraces() <RBRACE> {return obj;}
}

OntologyObject ActionWithoutBraces():
{ Token t; Proposition obj1;
}
{
 <ACTION> (   t=<WORD>
            | <LBRACE> (t=<WORD>)+ <RBRACE>)
 <LBRACE> obj1=SL0FunctionalTermWithoutBraces() <RBRACE>
         { Action obj = new Action();
           obj.setName("action"); 
           obj.setActor(t.image);
	   obj.setActionType(obj1.getName());
	   for (int i=0; i<obj1.getNumberOfTerms(); i++) 
             obj.addActionParameter(obj1.getTerm(i));
	   return obj; }
}



OntologyObject SL0Term() :
{ Token t;
  String s;
  SimpleValue sv;
  OntologyObject obj;
}
{
(    t=<WORD>
   | t=<STRINGLITERAL> 
   | t=<DATETIME>	   
   | t=<DATE>          
)
   {sv = new SimpleValue(); sv.setValue(t.image); return sv;} 

| s=Number()      
   {sv = new SimpleValue(); sv.setValue(s); return sv;} 

| <LBRACE> 
  (   obj=ActionWithoutBraces() 
    | obj=SL0FunctionalTermWithoutBraces() )
  <RBRACE>
  { return obj;}   
}



Proposition SL0FunctionalTermWithoutBraces():
{
 Proposition obj = new Proposition();
 OntologyObject obj1;
 Token t;
}
{
 t=<WORD> (obj1=SL0Term() {obj.addTerm(obj1);})* 
 {obj.setName(t.image); return obj;}
}


String Number():
{ Token t; }
{ 
  t=<INTEGER>   {return t.image;}
| t=<FLOATONE>  {return t.image;}
| t=<FLOATTWO>  {return t.image;}
}









/*   T O K E N    D E F I N I T I O N  */

<DEFAULT>
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<DEFAULT>
TOKEN:
{
  < LBRACE     : "("           > 
| < RBRACE     : ")"           >
| < ACTION     : "action"      > 
| < DONE       : "done"        >  	
| < IOTA       : "iota"        >
| < DATE       : (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) "/" 
                 (["0"-"9"]) (["0"-"9"]) "/" (["0"-"9"]) (["0"-"9"]) >
|  < DATETIME  :    ("+")? (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"])
                           (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) ["t","T"]
                           (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"])
                           (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["a"-"z","A"-"Z"])? > 
| < WORD       :  ["!" , "\"" , "$"-"'" , "*" , "+" , "," , "." , "/" , ":"-"~"] (["*"-"~","!"-"'"])* > 
| <STRINGLITERAL: "\"" (~["\""] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\""> 
| < INTEGER :       (["+","-"])? (["0"-"9"])+ >
| < FLOATONE :      (["+","-"])? ((["0"-"9"])+ "." (["0"-"9"])* | (["0"-"9"])* "." (["0"-"9"])+)
                    (["e","E"] (["-","+"])? (["0"-"9"])+)? >
| < FLOATTWO :      (["+","-"])? (["0"-"9"])+ ["e","E"] (["-","+"])? (["0"-"9"])+  >
}	













