/* Generated By:JavaCC: Do not edit this line. SL0Parser.java */
/* $Id: SL0Parser.jj,v 1.2 1999/01/29 06:22:05 bellifemine Exp bellifemine $

   $Log: SL0Parser.jj,v $
   Revision 1.2  1999/01/29 06:22:05  bellifemine
   <>

   Revision 1.1  1999/01/29 03:33:28  bellifemine
   Initial revision

   Revision 1.1  1999/01/18 15:44:47  bellifemine
   Initial revision

   Revision 1.2  1998/12/16 12:52:50  bellifemine
   Removed bug in OntologyObject.toString()

   Revision 1.1  1998/12/14 11:58:58  bellifemine
   Initial revision

*/

package demo.MeetingScheduler.CLP;
import java.io.*;

/**
 * This class implements the content language parser of the SL0 Language.
 * It takes in input a String with the content to parse and gives in output
 * a tree. Each node of the tree is an OntologyObject class.
 * <p> The parser must be used as follows:
 * <code> 
 * <p> ACLMessage msg = myAgent.receive();
 * <p> SL0Parser parser = SL0Parser.create();
 * <p> try { 
 * <p>     OntologyObject obj = parser.parse(new StringReader(msg.getContent()), msg.getType());
 * <p>     switch (obj.getType()) :
 * <p>      case ACTION_TYPE: { Action a=(Action)obj; 
 * <p>                          apply to a the interface of Action.java }
 * <p>      case OBJECT_TYPE: { Concept c=(Concept)obj; 
 * <p>                          apply to c the interface of Concept.java }
 * <p>      case PROPOSITION_TYPE: { Proposition p=(Proposition)obj; 
 * <p>                          apply to p the interface of Proposition.java }
 * <p>      case OBJECTDESCRIPTOR_TYPE: { ObjectDescriptor od=(ObjectDescriptor)obj; 
 * <p>                          apply to od the interface of ObjectDescriptor.java }
 * <p>      case SIMPLEVALUE_TYPE: { SimpleValue s=(SimpleValue)obj; 
 * <p>                          apply to s the interface of SimpleValue.java }
 * <p>      case MULTIVALUE_TYPE: { MultiValue m=(MultiValue)obj; 
 * <p>                          apply to m the interface of MultiValue.java }
 * <p>     }
 * <p> catch (CLP.ParseException pe) {
 * <p>     pe.printStackTrace();
 * <p>     System.exit(1); // parsing error
 * <p> }
 * </code>
 * <p> Notice that the direct interface provided by OntologyObject should
 * never be used and the object returned by the parser should always be
 * first casted to its actual type and then used.
 * <p> The classes derived by OntologyObject can also be used to create
 * the content message, by calling their set methods and then by calling
 * <code> msg.setContent(object.toString()); </code>
 * <p>
 * <img src="OntologyObject.jpg">
 * @see OntologyObject
*/
public class SL0Parser implements SL0ParserConstants {

  /**
   * This method allows the parser to be also a stand-alone Java application
   * You can run the parser simply typing 
   * <code>java myagents.SL0Parser < myagents\content.txt
   *
   * @param args is the list of arguments to the application 
   * @exception ParseException is generated when there is a parsing error
   */
  public static void main(String args[]) throws ParseException {
    String    aclType = "cfp";
    SL0Parser parser = new SL0Parser(System.in);
    int i=0;

    while (true) {
      System.out.println("This main has been compiled only to parse " + aclType);
      try {
        System.out.println("MESSAGE No. "+i);
        OntologyObject c = parser.ContentExpression(aclType);
        System.out.println(c.toString());
        i++;
      }
      catch(ParseException pe) {
        pe.printStackTrace();
        System.exit(1);
      }
    }
  }

  public static SL0Parser create() {
    Reader r = new StringReader("");
    return new SL0Parser(r);
  }

 /**
  * This method parses a Reader and returns an OntologyObject
  * @param text contains the text to be parsed
  * @param ACLMessageType contains the string with the type of ACLMessage to
  * which this message refers (e.g. "inform", "request", ...)
   * @exception ParseException is generated when there is a parsing error
  */
  public OntologyObject parse(Reader text, String ACLMessageType) throws ParseException {
    ReInit(text);
    return ContentExpression(ACLMessageType);
  }


  /**
   * given a string with an ACLMessageType returns an integer according to
   * the expected content:
   * 0 if a Proposition is expected
   * 1 if an Action is expected
   * 2 if an ObjectDescriptor is expected
   * 3 if a t-uple Action + Proposition is expected
   * -1 otherwise
  */
  private int ACLMessageTypeToInt(String t) {
   if (t.equalsIgnoreCase("accept-proposal")) return 3;
   if (t.equalsIgnoreCase("agree")) return 3;
   if (t.equalsIgnoreCase("cancel")) return 1;
   if (t.equalsIgnoreCase("cfp")) return 3;
   if (t.equalsIgnoreCase("confirm")) return 0;
   if (t.equalsIgnoreCase("disconfirm")) return 0;
   if (t.equalsIgnoreCase("failure")) return 3;
   if (t.equalsIgnoreCase("inform")) return 0;
   if (t.equalsIgnoreCase("not-understood")) return 3;
   if (t.equalsIgnoreCase("propose")) return 3;
   if (t.equalsIgnoreCase("query-if")) return 0;
   if (t.equalsIgnoreCase("query-ref")) return 2;
   if (t.equalsIgnoreCase("refuse")) return 3;
   if (t.equalsIgnoreCase("reject-proposal")) return 3;
   if (t.equalsIgnoreCase("request")) return 1;
   if (t.equalsIgnoreCase("request-when")) return 3;
   if (t.equalsIgnoreCase("request-whenever")) return 3;
   if (t.equalsIgnoreCase("subscribe")) return 2;
   return -1;
  }

  /**
   * This method parse a content expression and returns a tree of java objects,
   * starting from the returned OntologyObject
   * that represents the expression
   * @param ACLMessageType is the string with the type of ACLMessage that
   * embeddes this content (e.g. "request", "inform", ...)
   * @exception ParseException is generated when there is a parsing error
   * @return the root of the tree of java objects
  */
  public OntologyObject ContentExpression(String ACLMessageType) throws ParseException {
   int i = ACLMessageTypeToInt(ACLMessageType);
   switch (i) {
   case 0: return Proposition();
   case 1: return Action();
   case 2: return ObjectDescriptor();
   case 3: return ActionAndProposition();
   default: return Proposition();
   }
  }

/*   P R O D U C T I O N    R U L E S  */
  final public OntologyObject ActionAndProposition() throws ParseException {
  MultiValue obj = new MultiValue();
  OntologyObject obj1,obj2;
    jj_consume_token(LBRACE);
    obj1 = Action();
    obj2 = Proposition();
    jj_consume_token(RBRACE);
   obj.addValue(obj1); obj.addValue(obj2); {if (true) return obj;}
    throw new Error("Missing return statement in function");
  }

  final public OntologyObject Proposition() throws ParseException {
  OntologyObject obj;
  Proposition objj = new Proposition();
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      obj = PropositionWithoutBraces();
      jj_consume_token(RBRACE);
                                                   {if (true) return(obj);}
      break;
    case WORD:
      t = jj_consume_token(WORD);
            objj.setName(t.image); {if (true) return(objj);}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public OntologyObject PropositionWithoutBraces() throws ParseException {
  Token t,t2;
  Proposition obj = new Proposition();
  OntologyObject obj1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DONE:
      jj_consume_token(DONE);
      obj1 = Action();
                        obj.setName("done");
                        obj.addTerm(obj1);
                        {if (true) return obj;}
      break;
    case WORD:
      t = jj_consume_token(WORD);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case DATE:
        case DATETIME:
        case WORD:
        case STRINGLITERAL:
        case INTEGER:
        case FLOATONE:
        case FLOATTWO:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        obj1 = SL0Term();
                  obj.addTerm(obj1);
      }
   obj.setName(t.image); {if (true) return obj;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public OntologyObject ObjectDescriptor() throws ParseException {
  Token t;
  ObjectDescriptor obj=new ObjectDescriptor();
  OntologyObject obj2;
    jj_consume_token(LBRACE);
    jj_consume_token(IOTA);
    t = jj_consume_token(WORD);
    jj_consume_token(LBRACE);
    obj2 = PropositionWithoutBraces();
    jj_consume_token(RBRACE);
    jj_consume_token(RBRACE);
     obj.setIotaPattern(0);
     obj.setObjectName(t.image);
     obj.addDescription((Proposition)obj2);
     {if (true) return obj;}
    throw new Error("Missing return statement in function");
  }

  final public OntologyObject Action() throws ParseException {
  OntologyObject obj;
    jj_consume_token(LBRACE);
    obj = ActionWithoutBraces();
    jj_consume_token(RBRACE);
                                               {if (true) return obj;}
    throw new Error("Missing return statement in function");
  }

  final public OntologyObject ActionWithoutBraces() throws ParseException {
  Token t; Proposition obj1;
    jj_consume_token(ACTION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      t = jj_consume_token(WORD);
      break;
    case LBRACE:
      jj_consume_token(LBRACE);
      label_2:
      while (true) {
        t = jj_consume_token(WORD);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WORD:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
      }
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(LBRACE);
    obj1 = SL0FunctionalTermWithoutBraces();
    jj_consume_token(RBRACE);
           Action obj = new Action();
           obj.setName("action");
           obj.setActor(t.image);
           obj.setActionType(obj1.getName());
           for (int i=0; i<obj1.getNumberOfTerms(); i++)
             obj.addActionParameter(obj1.getTerm(i));
           {if (true) return obj;}
    throw new Error("Missing return statement in function");
  }

  final public OntologyObject SL0Term() throws ParseException {
  Token t;
  String s;
  SimpleValue sv;
  OntologyObject obj;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATE:
    case DATETIME:
    case WORD:
    case STRINGLITERAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        t = jj_consume_token(WORD);
        break;
      case STRINGLITERAL:
        t = jj_consume_token(STRINGLITERAL);
        break;
      case DATETIME:
        t = jj_consume_token(DATETIME);
        break;
      case DATE:
        t = jj_consume_token(DATE);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    sv = new SimpleValue(); sv.setValue(t.image); {if (true) return sv;}
      break;
    case INTEGER:
    case FLOATONE:
    case FLOATTWO:
      s = Number();
    sv = new SimpleValue(); sv.setValue(s); {if (true) return sv;}
      break;
    case LBRACE:
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ACTION:
        obj = ActionWithoutBraces();
        break;
      case WORD:
        obj = SL0FunctionalTermWithoutBraces();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RBRACE);
    {if (true) return obj;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Proposition SL0FunctionalTermWithoutBraces() throws ParseException {
 Proposition obj = new Proposition();
 OntologyObject obj1;
 Token t;
    t = jj_consume_token(WORD);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case DATE:
      case DATETIME:
      case WORD:
      case STRINGLITERAL:
      case INTEGER:
      case FLOATONE:
      case FLOATTWO:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_3;
      }
      obj1 = SL0Term();
                           obj.addTerm(obj1);
    }
  obj.setName(t.image); {if (true) return obj;}
    throw new Error("Missing return statement in function");
  }

  final public String Number() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      t = jj_consume_token(INTEGER);
                 {if (true) return t.image;}
      break;
    case FLOATONE:
      t = jj_consume_token(FLOATONE);
                 {if (true) return t.image;}
      break;
    case FLOATTWO:
      t = jj_consume_token(FLOATTWO);
                 {if (true) return t.image;}
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  public SL0ParserTokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[10];
  final private int[] jj_la1_0 = {0x1020,0x1fc20,0x1100,0x1000,0x1020,0x3c00,0x1080,0x1fc20,0x1fc20,0x1c000,};

  public SL0Parser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new SL0ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public SL0Parser(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new SL0ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public SL0Parser(SL0ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  public void ReInit(SL0ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[17];
    for (int i = 0; i < 17; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 17; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
