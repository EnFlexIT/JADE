/*****************************************************************
JADE - Java Agent DEvelopment Framework is a framework to develop multi-agent systems in compliance with the FIPA specifications.
Copyright (C) 2000 CSELT S.p.A. 

GNU Lesser General Public License

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation, 
version 2.1 of the License. 

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA  02111-1307, USA.
*****************************************************************/

options {
//  LOOKAHEAD = 1;	      
//  CHOICE_AMBIGUITY_CHECK = 2;
//  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = true;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = true;
//  UNICODE_INPUT = false;
//  IGNORE_CASE = true;
//  USER_TOKEN_MANAGER = false;
//  USER_CHAR_STREAM = false;
//  BUILD_PARSER = true;
//  BUILD_TOKEN_MANAGER = true;
//  SANITY_CHECK = true;
//  FORCE_LA_CHECK = true;	// Force LookAhead Checking
}

PARSER_BEGIN(SL0Parser)

package jade.lang.sl;

import jade.lang.Codec;

import jade.onto.Frame;
import jade.onto.Ontology;
import jade.onto.TermDescriptor;
import jade.onto.OntologyException;
import jade.onto.DefaultOntology;

import java.io.BufferedReader;
import java.io.StringReader;
import java.io.InputStreamReader;

public class SL0Parser implements Codec {

  public String encode(Frame f, Ontology o) {
    return "";
  }

  public Frame decode(String s, Ontology o) throws Codec.CodecException {
    ReInit(new StringReader(s));
    try {
     return SL0Content(o);
    }
    catch(ParseException pe) {
      throw new Codec.CodecException("Parse exception", pe);
    }
    catch(TokenMgrError tme) {
      throw new Codec.CodecException("Token Manager error", tme);
    }

  }

  private boolean isConcept(Ontology o, String roleName) {
    try {
      return o.isConcept(roleName);
    }
    catch(OntologyException oe) {
      return false;
    }
  }

  private boolean isAction(Ontology o, String roleName) {
    try {
      return o.isAction(roleName);
    }
    catch(OntologyException oe) {
      return false;
    }
  }

  private boolean isPredicate(Ontology o, String roleName) {
    try {
      return o.isPredicate(roleName);
    }
    catch(OntologyException oe) {
      return false;
    }
  }

  public static void main(String[] args) {
    System.out.println("SL0 Parser starting...");
    SL0Parser theParser = new SL0Parser(new BufferedReader(new InputStreamReader(System.in)));
    try {
      Ontology o = new DefaultOntology();

      // DF supported actions
      o.addFrame("register", Ontology.ACTION_TYPE, new TermDescriptor[] { 
	new TermDescriptor("arg0", Ontology.CONCEPT_TYPE, ":df-description", Ontology.M)
      });

      o.addFrame("deregister", Ontology.ACTION_TYPE, new TermDescriptor[] { 
	new TermDescriptor("arg0", Ontology.CONCEPT_TYPE, ":df-description", Ontology.M)
      });

      o.addFrame("modify", Ontology.ACTION_TYPE, new TermDescriptor[] { 
	new TermDescriptor("arg0", Ontology.CONCEPT_TYPE, ":df-description", Ontology.M)
      });

      o.addFrame("search", Ontology.ACTION_TYPE, new TermDescriptor[] { 
	new TermDescriptor("arg0", Ontology.CONCEPT_TYPE, ":df-description", Ontology.M),
	new TermDescriptor("arg1", Ontology.PREDICATE_TYPE, ":df-depth", Ontology.O),
	new TermDescriptor("arg2", Ontology.PREDICATE_TYPE, ":resp-req", Ontology.O)
      });

      o.addFrame(":df-depth", Ontology.PREDICATE_TYPE, new TermDescriptor[] {
	new TermDescriptor("Fn",Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor("arg", Ontology.LONG_TYPE, Ontology.M),
      });

      o.addFrame(":resp-req", Ontology.PREDICATE_TYPE, new TermDescriptor[] {
	new TermDescriptor("Fn",Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor("arg", Ontology.LONG_TYPE, Ontology.M),
      });

      // AMS supported actions
      o.addFrame("register-agent", Ontology.ACTION_TYPE, new TermDescriptor[] {
	new TermDescriptor("arg0", Ontology.CONCEPT_TYPE, ":ams-description", Ontology.M)
      });

      o.addFrame("deregister-agent", Ontology.ACTION_TYPE, new TermDescriptor[] {
	new TermDescriptor("arg0", Ontology.CONCEPT_TYPE, ":ams-description", Ontology.M)
      });

      o.addFrame("authenticate", Ontology.ACTION_TYPE, new TermDescriptor[] {
	new TermDescriptor("arg0", Ontology.CONCEPT_TYPE, ":ams-description", Ontology.M)
      });

      o.addFrame("modify-agent", Ontology.ACTION_TYPE, new TermDescriptor[] {
	new TermDescriptor("arg0", Ontology.CONCEPT_TYPE, ":ams-description", Ontology.M)
      });


      // Concepts

      o.addFrame(":service-description", Ontology.CONCEPT_TYPE, new TermDescriptor[] {
	new TermDescriptor(":service-name", Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor(":service-type", Ontology.STRING_TYPE, Ontology.M)
      });

      o.addFrame(":ams-description", Ontology.CONCEPT_TYPE, new TermDescriptor[] {
	new TermDescriptor(":agent-name", Ontology.STRING_TYPE, Ontology.O),
	new TermDescriptor(":address", Ontology.STRING_TYPE, Ontology.O),
	new TermDescriptor(":delegate-agent", Ontology.STRING_TYPE, Ontology.O),
	new TermDescriptor(":forward-address", Ontology.STRING_TYPE, Ontology.O),
	new TermDescriptor(":ap-state", Ontology.STRING_TYPE, Ontology.O),
	new TermDescriptor(":ownership", Ontology.STRING_TYPE, Ontology.O),
      });

      o.addFrame(":df-description", Ontology.CONCEPT_TYPE, new TermDescriptor[] {
	new TermDescriptor(":agent-name", Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor(":agent-address", Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor(":agent-services", Ontology.CONCEPT_TYPE,":service-description", Ontology.M),
	new TermDescriptor(":agent-type", Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor(":interaction-protocols", Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor(":ontology", Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor(":ownership", Ontology.STRING_TYPE, Ontology.M),
	new TermDescriptor(":df-state", Ontology.STRING_TYPE, Ontology.M)
      });

      Frame result = theParser.SL0Content(o);
      result.dump();
    }
    catch(OntologyException oe) {
      oe.printStackTrace();
    }
    catch(ParseException pe) {
      pe.printStackTrace();
    }
    catch(TokenMgrError tme) {
      tme.printStackTrace();
    }
  }

}

PARSER_END(SL0Parser)


/* 

   The following grammar productions try to match as closely as
   possible the SL0 grammar given in FIPA 97, Version 2.0 Part 2. The
   differences are as follows:

   1) In order to keep single lookahead, braces have been factored out
      whenever possible. So, the parser methods corresponding to
      SL0ActionExpression and to SL0FunctionalTerm don't expect
      neither opening nor closing brace. Braces are explicitly
      indicated in the calling methods/productions.

   2) In order to keep the single lookahead requirement, the
      derivation chain
      SL0ContentExpression --> SL0Wff --> SL0AtomicFormula --> SLPropositionSymbol --> <WORD>
      has been shortened to SL0ContentExpression --> <WORD>. This
      allows us to factor out the opening brace, which is common to
      all the other branches of the parse tree.

   3) Identical productions have been merged into one; these are:
      - SLPropositionSymbol, "true" and "false", that all result in a single <WORD> token.
      - SLFunctionalTerm and "(" SLPredicateSymbol SL0Term* ")", that are exactly the same.

   4) Due to the production merging of the previous point, the
      SL0AtomicFormula production is no more needed, so it has been
      removed; now there's a rule SL0Wff --> SL0FunctionalTerm. The
      only difference with the original grammar is that here "result"
      is no more a reserved word; the section B.2.5 states that "a
      standard predicate 'result', of arity two, is introduced to the
      language". This does not seem to forbid having other, user
      defined, predicates named 'result' but with different
      arity. This is indeed possible with the current grammar, but can
      be troublesome with the standard one.

   5) A special JavaCC feature, namely "semantic lookahead", has been
      exploited to support key/value pairs for concept slots, but
      simple argument lists for actions and predicates. An ontology
      lookup is performed in order to distinguish among the two cases.

*/



/*   P R O D U C T I O N    R U L E S  */

/**
* This production rule represents the more general expression that can
* serve as content for an ACL message. Since different communicative
* acts have different content (action expressions for
* <code>request</code>, predicate for <code>inform</code>, etc.), any
* allowed SL content expression can be parsed from here.
*/
Frame SL0Content(Ontology o) :
{ 
  Frame result;
  Token t;
}
{
  ( t = <WORD> { result = new Frame(t.image); } | <LBRACE> ( result = ActionExpression(o) | result = Wff(o) ) <RBRACE> )
  { return result; }
}


Frame Wff(Ontology o):
{
  Frame result;
}
{
  ( result = SL0ActionOp(o) | result = FunctionalTerm(o) )
  { return result; }
}


Frame ActionExpression(Ontology o):
{
  Frame result;
  Object agentID;
}
{
  <ACTION> agentID = AID(o) <LBRACE> result = FunctionalTerm(o) { result.putSlot(":actor", agentID); } <RBRACE>
  { return result; }
}


Frame SL0ActionOp(Ontology o):
{
  Frame result;
  Frame action;
}
{
  <DONE> <LBRACE> action = ActionExpression(o) { result = new Frame("Done"); result.putSlot(action); } <RBRACE>
  { return result; }
}

Frame FunctionalTerm(Ontology o):
{
  Frame result;
  Token t;
}
{
  t = <WORD> { result = new Frame(t.image); } // The function name becomes the frame name
(
  LOOKAHEAD({ isConcept(o, t.image)   }) Concept(o, result) // if it's a Concept, fill the Frame with key/value pairs

| LOOKAHEAD({ isAction(o, t.image)    }) Action(o, result)  // if it's an Action, fill the Frame with unnamed arguments

| LOOKAHEAD({ isPredicate(o, t.image) }) Predicate(o, result) // if it's a Predicate, fill the Frame with unnamed terms

| { throw new ParseException("Ontological inconsistency: '" + t.image + "' must be a Concept, an Action or a Predicate"); }
)
  { return result; }
}

void Concept(Ontology o, Frame result):
{
  Token name;
  Object value;
}
{
  ( <LBRACE> name = <WORD> value = SL0Term(o) <RBRACE> { result.putSlot(name.image, value); } )+ // At least one slot
}

void Action(Ontology o, Frame result):
{
  Object arg;
}
{
  ( arg = SL0Term(o) { result.putSlot(arg); } )+ // At least one argument
}

void Predicate(Ontology o, Frame result):
{
  Object arg;
}
{
  ( arg = SL0Term(o) { result.putSlot(arg); } )+ // At least one term
}

Object SL0Term(Ontology o) :
{
  Object result;
}
{
  ( result = String() | result = Number() | <LBRACE> result = FunctionalTerm(o) <RBRACE> )
  { return result; }
}


/**
* <p> <code> String = WORD | STRING_LITERAL  </code>
*/
String String() :
{ Token t;}
{
  t=<WORD>		{return t.image;}
| t=<STRING_LITERAL>	{return t.image;}
}

/*
* AID. 
*/
Object AID(Ontology o) :
{String s; }
{ 
  s = String() { return s; } // FIPA97 agent name
}


/*
* <code> ACLCommunicativeActWithoutBraces = String ( String SL0Term )* </code>
*/

/*
void ACLCommunicativeActWithoutBraces(Ontology o) :
{String s; }
{
 s=String() (String() SL0Term(o))*
 {if (jade.lang.acl.ACLMessage.getPerformative(s)==jade.lang.acl.ACLMessage.UNKNOWN) throw new ParseException(s+" is not a performative symbol"); } 	
}
*/

Object Number():
{ 
  Token t;
}
{ 
  t = <INTEGER> { return new Long(t.image); }
| t = <FLOATONE> { return new Double(t.image); }
| t = <FLOATTWO> { return new Double(t.image); }
}







/*   T O K E N    D E F I N I T I O N  */

<DEFAULT>
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<DEFAULT>
TOKEN:
{
  < LBRACE     : "("       > 
| < RBRACE     : ")"       >
| < ACTION     : "action"  >
| < DONE: "done">
| < INTEGER :       (["+","-"])? (["0"-"9"])+ >
| < FLOATONE :      (["+","-"])? ((["0"-"9"])+ "." (["0"-"9"])* | (["0"-"9"])* "." (["0"-"9"])+)
                    (["e","E"] (["-","+"])? (["0"-"9"])+)? >
| < FLOATTWO :      (["+","-"])? (["0"-"9"])+ ["e","E"] (["-","+"])? (["0"-"9"])+  >
| < WORD: (~["\u0000"-"\u001F"," ","(",")","\""]) (~["\u0000"-"\u001F"," ","(",")"])* >
|  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}	













