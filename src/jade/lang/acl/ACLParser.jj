////////////////////////////////////////////////////////////////////////
// Copyright (c) 1998 FIPA All Rights Reserved
//
// This software module was developed by
// CSELT (Centro Studi e Laboratori Telecomunicazioni S.p.A)
// and DII University of Parma
// in the course of development of the FIPA97 standard. 
// It is an implementation of the parser of the 
// FIPA97 Agent Communication Language
// specified by the FIPA97 standard.
//
//
//
// The copyright of this software belongs to FIPA. FIPA gives
// free license to its members to use this software module or
// modifications thereof for hardware or software products claiming
// conformance to the FIPA97 standard.
//
//
//
// Those intending to use this software module in hardware or software
// products are advised that use may infringe existing  patents. The
// original developers of this software module and their companies, the
// subsequent editors and their companies, and FIPA have no liability
// for use of this software module or modification thereof in an
// implementation.
//
//
//
// FIPA thanks Fabio Bellifemine, Agostino Poggi, and Paolo Marenzoni
// for releasing the copyright of this software.
// Part of this software has been developed within the framework of the
// FACTS project, AC317, of the European ACTS Programme.
////////////////////////////////////////////////////////////////////////
/* 
 *
 * $Log$
 * Revision 1.7  1999/03/07 22:59:14  rimassa
 * Modified grammar rules and actions to support either a single agent
 * name or a list of agent names as value for ':receiver' slot.
 *
 * Revision 1.6  1998/12/13 16:39:50  rimassa
 * Fixed a bug involving date and time representation.
 *
 * Revision 1.1  1998/12/09 09:55:41  bellifemine
 * Initial revision
 *
 * Revision 1.11  1998/11/11 11:21:32  bellifemine
 * Versione 0.9 inviata da Giovanni + modicato da me il Readme (tolto il riferimento allo RMI registry), rimessa la versione precedente di GUIProperties.java altrimenti non funzionava la GUI, aggiunto l'esempio AgentTimeout.java
 *
 * Revision 1.5  1998/10/18 16:05:01  rimassa
 * Changed code to avoid using ACLMessage dump() method and default
 * constructor, since these two are now deprecated.
 *
 * Revision 1.4  1998/10/04 18:02:10  rimassa
 * Added a 'Log:' field to every source file.
 *
 * Revision 1.3  1998/08/08 18:58:07  rimassa
 * Added copyright message.
 * Fixed a problem with ParseError vs. ParseException to be able to use JavaCC 0.8pre1.
 *
 * Added a static Factory Method ACLParser.create() and a method
 * parse(java.io.Reader r) to be able to read input from any Reader.
 *

  
   ACLParser.jj is the Grammar File of the FIPA ACL.
     To generate the Java source code: javacc ACLParser.jj
     To compile the Java source code:  javac  ACLParser*.java
     To run the parser:                cd ..; java ACLParser.ACLParser < TestMessagges.txt

   Known bugs and/or limitations:
   - MIME Extension not supported
   - Content is parsed according to the ACL Grammar and not the Content Language Grammar
   - The definition of the token <WORD> does not allow to distinguish between AgentName
     and AgentAddress. This is because it includes the character "@".
     Further processing should be included in order to make this differentiation
*/

options {
  LOOKAHEAD = 1;	      
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = true;	// Force LookAhead Cecking
}

PARSER_BEGIN(ACLParser)

package jade.lang.acl;

import java.io.*;

public class ACLParser {
  ACLMessage msg = new ACLMessage("");

  public static void main(String args[]) throws ParseException {
    ACLParser parser = new ACLParser(System.in);
    
    while (true) {
      try {
	ACLMessage result = parser.Message();
	result.toText(new BufferedWriter(new OutputStreamWriter(System.out)));
      }
      catch(ParseException pe) {
	pe.printStackTrace();
	System.exit(1);
      }
    }
  }

  public static ACLParser create() {
    Reader r = new StringReader("");
    return new ACLParser(r);
  }

  public ACLMessage parse(Reader text) throws ParseException {
    ReInit(text);
    return Message();
  }

}

PARSER_END(ACLParser)

ACLMessage Message() :
{  msg.reset(); }
{
  <START> MessageType() (MessageParameter())* <END>  
 {
   return msg;
 }
}

void MessageType() :
{ Token t; }
{
  t= <MESSAGETYPE> 	{ msg.setType(t.image);}
}


void MessageParameter() :
{ String s; }
{
  <SENDER>          s=AgentName()			{ msg.setSource(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <RECEIVER>        ( RecipientExpr() | (s = AgentName() {msg.removeAllDests(); msg.addDest(s);}) ) { token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <CONTENT>         s=Expression()			{ msg.setContent(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <REPLY_WITH>      s=Expression()			{ msg.setReplyWith(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <REPLY_BY>        s=DateTimeToken()		{ msg.setReplyBy(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <IN_REPLY_TO>     s=Expression()			{ msg.setReplyTo(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <ENVELOPE>        s=KeyValuePairList()		{ msg.setEnvelope(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <LANGUAGE>        s=Expression()			{ msg.setLanguage(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <ONTOLOGY>        s=Expression()			{ msg.setOntology(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <PROTOCOL>        s=Word()				{ msg.setProtocol(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
| <CONVERSATION_ID> s=Expression()			{ msg.setConversationId(s); token_source.SwitchTo(MESSAGEPARAMETERSTATE);}
}


String Expression():
{ String s; String s1=new String(); }
{ 
  s=Word()						{return s;}
| s=Stringa()					{return s;}
| s=Number()					{return s;}
| s=DateTimeToken()				{return s;}
| <LBRACE> ( s=Expression() {s1+=(s+" ");} )* <RBRACE>		{return "("+s1+")";}
}


String KeyValuePairList():
{ String s; String s1=new String();}
{ 
  <LBRACE> (s=KeyValuePair() {s1+=(s+" ");} )* <RBRACE>		{return "("+s1+")";}
}


String KeyValuePair():
{ String s1,s2;}
{ 
  <LBRACE> s1=Word() s2=Expression() <RBRACE> 		{return ("("+s1+" "+s2+")");}
}


void RecipientExpr():
{ String s; }
{ 
<LBRACE> (s = AgentName() { msg.addDest(s); })+ <RBRACE>
}


String AgentName():
{ String s; }
{ 
  s=Word()					{return s;}
// the definition of the <WORD> Token includes also the production rule for AgentAddress
}


String Word():
{ Token t; }
{ 
  t=<WORD>	{ return t.image; }
}


String Stringa():
{ String s;}
{ 
  s=StringLiteral()			{return s;}
| s=ByteLengthEncodedString() 	{return s;}
}


String StringLiteral():
{ Token t; }
{ 
  t=<STRINGLITERAL>			{return t.image;}
}


String ByteLengthEncodedString():
{ Token t; /* int i=0; char c; */}
{ 
  t=<PREFIXBYTELENGTHENCODEDSTRING>  {return t.image;}
}


String Number():
{ String s;}
{ 
  s=Digit()			{return s;}
| s=Integer()			{return s;}
| s=Float() 			{return s;}
}


String DateTimeToken():
{ Token t; String s;}
{ 
  t=<DATETIME>				{return t.image;} 
}


String Digit():
{ Token t;}
{ 
  t=<DIGIT>				{return t.image;}
}


String Integer():
{ Token t; String s=new String();}
{ 
  // (t="+" {s+=t.image;} | t="-" {s+=t.image;})? ( t=<DIGIT> {s+=t.image;} )+	{return s;}*/
  t=<INTEGER>	{return t.image;}
}

String Float():
{ Token t;}
{ 
  t=<FLOATONE>			{return t.image;}
| t=<FLOATTWO>			{return t.image;}
}



<DEFAULT>
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<DEFAULT>
TOKEN:
{
  <START : "("> : MESSAGETYPESTATE 
}

<MESSAGETYPESTATE>
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<MESSAGETYPESTATE>
TOKEN:
{
  <MESSAGETYPE :  "accept-proposal"
                | "agree"		
                | "cancel"	
                | "cfp"			
                | "confirm"	
                | "disconfirm"	
                | "failure"		
                | "inform"		
                | "inform-if"		
                | "inform-ref"	
                | "not-understood"	
                | "propose"		
                | "query-if"	
                | "query-ref"	
                | "refuse"		
                | "reject-proposal"
                | "request"		
                | "request-when"	
                | "request-whenever"	
                | "subscribe"	>        : MESSAGEPARAMETERSTATE
}	

<MESSAGEPARAMETERSTATE>
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<MESSAGEPARAMETERSTATE>
TOKEN:
{
  <SENDER :          ":sender" >          : CONTENTSTATE
| <RECEIVER :        ":receiver" >        : CONTENTSTATE
| <CONTENT :         ":content" >         : CONTENTSTATE
| <REPLY_WITH :      ":reply-with" >      : CONTENTSTATE
| <REPLY_BY :        ":reply-by" >        : CONTENTSTATE
| <IN_REPLY_TO:      ":in-reply-to" >     : CONTENTSTATE
| <ENVELOPE :        ":envelope" >        : CONTENTSTATE
| <LANGUAGE :        ":language" >        : CONTENTSTATE
| <ONTOLOGY :        ":ontology" >        : CONTENTSTATE
| <PROTOCOL :        ":protocol" >        : CONTENTSTATE
| <CONVERSATION_ID : ":conversation-id" > : CONTENTSTATE
| <END :             ")" >                : DEFAULT
}

<CONTENTSTATE>
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

<CONTENTSTATE>
TOKEN:
{
  < DATETIME :      ("+")? (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"])
                           (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) ["t","T"]
                           (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"])
                           (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["0"-"9"]) (["a"-"z","A"-"Z"])? > 
|  < WORD :          ["!" , "\"" , "$"-"'" , "*" , "+" , "," , "." , "/" , ":"-"~"] (["*"-"~","!"-"'"])* >
| <STRINGLITERAL: "\"" (~["\""] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\""> 
| < DIGIT :         ["0"-"9"] >
| < INTEGER :       (["+","-"])? (["0"-"9"])+ >
| < FLOATONE :      (["+","-"])? ((["0"-"9"])+ "." (["0"-"9"])* | (["0"-"9"])* "." (["0"-"9"])+)
                    (["e","E"] (["-","+"])? (["0"-"9"])+)? >
| < FLOATTWO :      (["+","-"])? (["0"-"9"])+ ["e","E"] (["-","+"])? (["0"-"9"])+  >
| <PREFIXBYTELENGTHENCODEDSTRING :  "#" <INTEGER> "\"" > 
         {
            String tmp = matchedToken.image.substring(1,  
                                      matchedToken.image.length() - 1);
            int numBytes = Integer.parseInt(tmp);
		if (numBytes < 0) 
               throw new TokenMgrError("ERROR: PrefixByteLengthEncodedString with length < 0", TokenMgrError.STATIC_LEXER_ERROR);
            char[] bytes = new char[numBytes];
            int i = 0; 
	 	
            while (numBytes-- > 0) 
			try {
	                bytes[i++] = input_stream.readChar(); 
			} catch (IOException e) {
                        System.out.println("IOException during PREFIXBYTELENGTHENCODEDSTRING");
                        throw new TokenMgrError(true, curLexState, input_stream.getEndLine(), input_stream.getEndColumn(),input_stream.GetImage(), curChar, TokenMgrError.LEXICAL_ERROR);
			}	
            // If you want, you can add bytes to matchedToken.image here.
		matchedToken.image = new String(bytes);
         }
 | <RBRACE : ")" >
 | <LBRACE : "(" >
}



